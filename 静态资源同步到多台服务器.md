# 静态资源同步到多台服务器的实现方案

在现代Web应用架构中，为了提高系统的可用性和性能，通常会部署多台服务器来提供服务。然而，这种分布式部署方式带来了一个挑战：如何在多台服务器之间同步静态资源，如图片、文档等文件。本文将基于一个实际的博客系统项目，介绍静态资源同步到多台服务器的实现逻辑。

## 项目背景

该博客系统支持用户上传文章及相关的图片资源。文章内容以Markdown格式存储，同时配有封面图片。这些静态资源需要在多台服务器之间保持同步，以确保用户无论访问哪台服务器都能获取到完整的文章内容。

## 核心实现原理

### 1. 资源上传与存储

当用户上传文章时，系统会将图片和Markdown文件存储在服务器的指定目录中。在我们的示例中，图片存储在`/image/`目录，Markdown文件存储在`/md/`目录。

```java
public void insertArticleResourcePath(ArticleResourcePath articleResourcePath, File image ,File md) {
    try {
        // 创建目录（如果不存在）
        File imageDir = new File(path + "/image/");
        File mdDir = new File(path + "/md/");

        if (!imageDir.exists()) {
            boolean imageDirCreated = imageDir.mkdirs();
            if (!imageDirCreated) {
                throw new RuntimeException("无法创建图片目录: " + imageDir.getAbsolutePath());
            }
        }
        if (!mdDir.exists()) {
            boolean mdDirCreated = mdDir.mkdirs();
            if (!mdDirCreated) {
                throw new RuntimeException("无法创建Markdown文件目录: " + mdDir.getAbsolutePath());
            }
        }
        // 使用更可靠的文件移动方法
        long timestamp = System.currentTimeMillis();
        articleResourcePath.setTimestamp(timestamp);
        Path imagePath = Paths.get(image.getAbsolutePath());
        Path newImagePath = Paths.get(imageDir.getAbsolutePath(), image.getName());
        Files.move(imagePath, newImagePath, StandardCopyOption.REPLACE_EXISTING);
        Path mdPath = Paths.get(md.getAbsolutePath());
        Path newMdPath = Paths.get(mdDir.getAbsolutePath(), md.getName());
        Files.move(mdPath, newMdPath, StandardCopyOption.REPLACE_EXISTING);
        // 设置文章资源路径
        articleResourcePath.setImage("image/" + image.getName());
        articleResourcePath.setMd("md/" + md.getName());
        articleResourcePath.setLike(0);
        articleResourcePath.setComment(0);
        articleResourcePath.setBrowse(0);
        articleResourcePathMapper.insertArticleResourcePath(articleResourcePath);
    } catch (IOException e) {
        throw new RuntimeException("文件移动失败: " + e.getMessage(), e);
    }
}
```

### 2. 负载均衡与服务注册

系统采用了一个自定义的负载均衡器，通过服务注册机制来管理多台服务器。每台服务器启动时会向负载均衡器注册自己的信息，包括地址、接口名称、CPU和内存使用情况等。

```java
@PostMapping("/register")
public String register(@RequestBody List<Map<String, Object>> newServices) {
    synchronized (userData) {
        for (Map<String, Object> newService : newServices) {
            String address = (String) newService.get("address");
            if (address == null || address.isEmpty()) {
                continue;
            }

            // 检查服务是否已存在（根据地址判断）
            boolean serviceExists = userData.stream()
                    .anyMatch(service -> address.equals(service.get("address")));

            if (serviceExists) {
                // 存在则更新服务信息（覆盖旧数据）
                userData.removeIf(service -> address.equals(service.get("address")));
            }
            // 添加新服务（或更新后的服务）
            userData.add(newService);
            // 更新最后注册时间（心跳时间）
            serviceLastRegister.put(address, LocalDateTime.now());
            System.out.println("服务注册/更新成功，地址：" + address);
        }
    }
    return "Services registered/updated successfully";
}
```

### 3. 请求代理与负载均衡

当用户请求访问文章资源时，请求首先到达负载均衡器，然后根据一定的策略转发到具体的服务器。

```java
@RequestMapping(value = "/proxy/**", method = {RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.DELETE})
public ResponseEntity<?> proxyRequest(HttpServletRequest request) {
    try {
        synchronized (userData) {
            if (userData.isEmpty()) {
                log.error("没有可用的服务实例");
                return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                        .body("没有可用的服务实例".getBytes());
            }

            // 解析请求路径（提取目标接口名称和剩余路径）
            String requestUri = request.getRequestURI();
            String[] pathParts = requestUri.replaceFirst("/proxy/", "").split("/", 2);
            String targetInfName = pathParts[0];
            String remainingPath = pathParts.length > 1 ? pathParts[1] : "";

            // 根据接口名称筛选目标服务
            List<Map<String, Object>> targetServices = userData.stream()
                    .filter(service -> targetInfName.equals(service.get("infName")))
                    .collect(Collectors.toList());

            if (targetServices.isEmpty()) {
                log.error("没有找到接口名称为 '" + targetInfName + "' 的服务");
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body("没有找到接口名称为 '" + targetInfName + "' 的服务".getBytes());
            }

            // 使用加权算法选择服务实例
            Map<String, Object> selectedService = selectServiceByWeight(targetServices, targetInfName);
            if (selectedService == null) {
                log.error("没有闲置的服务实例");
                return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                        .body("没有闲置的服务实例".getBytes());
            }

            // 构建目标服务URL并转发请求
            String url = buildTargetUrl((String) selectedService.get("address"), remainingPath, request);
            log.info("转发请求到服务：{}", url);

            // 调用支持服务降级的转发方法
            return forwardRequestWithFallback(request, url, targetServices, selectedService, targetInfName, remainingPath);
        }
    } catch (Exception e) {
        log.error("请求转发失败: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("请求转发失败: " + e.getMessage().getBytes());
    }
}
```

### 4. 资源同步机制

当某台服务器上缺少某个资源时，系统会从其他服务器获取该资源并保存到本地。这种机制确保了所有服务器上的资源保持一致。

```java
public void getNotFoundImages(String path) {
    HttpResponse<File> response = Unirest.get("http://luren.online:2345/proxy/image?filename="+path)
            .asFile(path);
    //将获取的文件保存到本地
    File file = response.getBody();
    System.out.println(response.getBody());
    if (file != null) {
        file.renameTo(new File(GetNotFoundResources.path +path));
    }
}

public void getNotFoundMd(String path) {
    HttpResponse<File> response = Unirest.get("http://luren.online:2345/proxy/md?filename="+path)
            .asFile(path);
    //将获取的文件保存到本地
    File file = response.getBody();
    System.out.println(response.getBody());
    if (file != null) {
        file.renameTo(new File(GetNotFoundResources.path +path));
    }
}
```

### 5. 资源清理机制

为了避免服务器上积累过多无用的资源文件，系统还实现了资源清理机制。定期检查本地文件与数据库记录的一致性，删除那些在数据库中不存在的本地文件。

```java
public void removeArticles(List<ArticleResourcePath> articles) {
    File mdDir = new File(path + "/md/");
    File imageDir = new File(path + "/image/");
    File[] imageFiles = imageDir.listFiles();
    File[] mdFiles = mdDir.listFiles();

    // 获取本地文件列表
    List<String> localMdList = new ArrayList<>();
    if (mdFiles != null) {
        for (File mdFile : mdFiles) {
            localMdList.add(mdFile.getName());
        }
    }

    List<String> localImageList = new ArrayList<>();
    if (imageFiles != null) {
        for (File imageFile : imageFiles) {
            localImageList.add(imageFile.getName());
        }
    }

    // 创建数据库中文件名的集合
    List<String> dbMdList = new ArrayList<>();
    List<String> dbImageList = new ArrayList<>();

    for (ArticleResourcePath article : articles) {
        if (article.getMd() != null && !article.getMd().isEmpty()) {
            String mdName = article.getMd().substring(article.getMd().lastIndexOf("/") + 1);
            dbMdList.add(mdName);
        }
        if (article.getImage() != null && !article.getImage().isEmpty()) {
            String imageName = article.getImage().substring(article.getImage().lastIndexOf("/") + 1);
            dbImageList.add(imageName);
        }
    }

    // 删除本地存在但数据库中不存在的md文件
    if (mdFiles != null) {
        for (File mdFile : mdFiles) {
            if (!dbMdList.contains(mdFile.getName())) {
                mdFile.delete();
            }
        }
    }

    // 删除本地存在但数据库中不存在的图片文件
    if (imageFiles != null) {
        for (File imageFile : imageFiles) {
            if (!dbImageList.contains(imageFile.getName())) {
                imageFile.delete();
            }
        }
    }
}
```

## 负载均衡策略

系统采用加权轮询算法进行负载均衡，根据服务器的CPU和内存使用情况动态分配权重，确保请求更多地转发到负载较低的服务器。

```java
private double calculateWeight(Map<String, Object> service) {
    try {
        String cpuStr = (String) service.get("CPU");
        String memoryStr = (String) service.get("memory");

        if (cpuStr == null || memoryStr == null) {
            return 1.0; // 缺失指标时使用默认权重
        }

        // 解析百分比（去除%符号）
        double cpuUsage = Double.parseDouble(cpuStr.replace("%", ""));
        double memoryUsage = Double.parseDouble(memoryStr.replace("%", ""));

        // 权重参数（CPU权重70%，内存30%）
        final double CPU_WEIGHT = 0.7;
        final double MEMORY_WEIGHT = 0.3;

        // 计算得分（使用率越低得分越高）
        double cpuScore = (100 - cpuUsage) * CPU_WEIGHT;
        double memoryScore = (100 - memoryUsage) * MEMORY_WEIGHT;

        return cpuScore + memoryScore;
    } catch (Exception e) {
        System.err.println("计算权重失败，服务：" + service.get("address") + "，错误：" + e.getMessage());
        return 1.0; // 异常时使用默认权重
    }
}
```

## 服务降级与容错

当某台服务器出现故障时，系统能够自动将请求转发到其他可用的服务器，确保服务的连续性。

```java
private ResponseEntity<byte[]> forwardRequestWithFallback(HttpServletRequest request, String url,
                                                     List<Map<String, Object>> targetServices,
                                                     Map<String, Object> selectedService,
                                                     String targetInfName, String remainingPath) throws Exception {
    // 创建已尝试服务的集合，避免重复尝试
    Set<String> triedServices = new HashSet<>();
    triedServices.add((String) selectedService.get("address"));

    try {
        // 初始尝试
        ResponseEntity<byte[]> response = forwardRequest(request, url);
        // 对于 5xx 错误，尝试降级处理
        if (response.getStatusCode().is5xxServerError()) {
            log.warn("服务 {} 返回5xx错误，尝试降级处理: {}", url, response.getStatusCode());
            throw new RuntimeException("5xx error occurred");
        }
        // 4xx 错误直接返回，因为响应体已经正确获取
        return response;
    } catch (Exception initialException) {
        log.warn("服务 {} 请求失败，尝试降级处理: {}", url, initialException.getMessage());

        // 尝试其他同名服务
        List<Map<String, Object>> availableServices = new ArrayList<>(targetServices);
        // 移除已尝试的服务
        availableServices.removeIf(service -> triedServices.contains(service.get("address")));

        while (!availableServices.isEmpty()) {
            // 使用加权算法选择下一个服务实例
            Map<String, Object> nextService = selectServiceByWeight(availableServices, targetInfName);
            if (nextService == null) {
                break;
            }

            // 从可用列表中移除已选择的服务
            String nextAddress = (String) nextService.get("address");
            availableServices.removeIf(service -> nextAddress.equals(service.get("address")));
            triedServices.add(nextAddress);

            // 构建新URL并尝试请求
            String nextUrl = buildTargetUrl(nextAddress, remainingPath, request);

            log.info("尝试降级到服务：{}", nextUrl);

            try {
                ResponseEntity<byte[]> response = forwardRequest(request, nextUrl);
                // 检查降级服务的响应码，只有5xx错误才继续尝试
                if (response.getStatusCode().is5xxServerError()) {
                    log.warn("降级服务 {} 返回5xx错误: {}", nextUrl, response.getStatusCode());
                    continue; // 继续尝试下一个服务
                }
                log.info("服务降级成功，使用服务: {}", nextUrl);
                return response;
            } catch (Exception retryException) {
                log.warn("降级服务 {} 请求失败: {}", nextUrl, retryException.getMessage());
                // 继续尝试下一个服务
            }
        }

        // 所有服务都失败了，返回错误响应
        log.error("所有同名服务实例都不可用");
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                .body("所有同名服务实例都不可用".getBytes());
    }
}
```

## 总结

通过上述机制，该博客系统实现了静态资源在多台服务器之间的同步。主要特点包括：

1. **资源上传与存储**：用户上传的资源被存储在指定目录，并记录在数据库中
2. **服务注册与发现**：服务器启动时自动注册，负载均衡器维护服务列表
3. **负载均衡**：根据服务器负载情况动态分配请求
4. **资源同步**：当某台服务器缺少资源时，自动从其他服务器获取
5. **资源清理**：定期清理无用的本地资源文件
6. **容错机制**：当某台服务器出现故障时，自动将请求转发到其他服务器

这套方案确保了多台服务器之间的资源一致性，提高了系统的可用性和用户体验。