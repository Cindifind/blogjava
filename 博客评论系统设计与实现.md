# 博客评论系统设计与实现

在现代博客系统中，评论功能是增强用户互动性和社区感的重要组成部分。本文将详细介绍我们博客系统中评论模块的设计思路、架构组成以及具体实现方式。

## 系统架构概览

我们的评论系统采用经典的分层架构模式，主要包括以下几个层次：

1. **Controller层** - 处理HTTP请求和响应
2. **Service层** - 实现业务逻辑
3. **Mapper层** - 数据库操作接口
4. **Model层** - 数据模型定义

这种分层架构保证了代码的清晰性、可维护性和可扩展性。

## 数据模型设计

### Comment实体类

评论系统的核心是[Comment](file:///E:/demo/src/main/java/com/example/demo/model/Comment.java#L8-L142)实体类，它包含了以下关键属性：

- `timestamp`: 评论唯一标识符（使用时间戳）
- `articleId`: 所属文章ID
- `author`: 评论作者
- `email`: 评论者邮箱
- `content`: 评论内容
- `parentId`: 父评论ID（用于回复功能）
- `reply`: 回复数量统计

```java
public class Comment {
    private Long timestamp;
    private Long articleId;
    private String author;
    private String email;
    private String content;
    private Long parentId;
    private int reply;
    // getters and setters...
}
```

### 数据库表结构

评论数据存储在`comments`表中，表结构如下：

```sql
CREATE TABLE comments (
    timestamp BIGINT PRIMARY KEY,
    article_id BIGINT NOT NULL,
    email VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    parent_id BIGINT NULL,
    FOREIGN KEY (article_id) REFERENCES article_resource_path(timestamp) ON DELETE CASCADE,
    FOREIGN KEY (parent_id) REFERENCES comments(timestamp) ON DELETE CASCADE,
    INDEX idx_article_id (article_id)
);
```

该表结构支持：
- 通过外键约束保证数据一致性
- 级联删除确保当文章或评论被删除时相关评论也会被清理
- 索引优化查询性能

## 功能实现详解

### 1. 添加评论

添加评论功能由[CommentController](file:///E:/demo/src/main/java/com/example/demo/controller/CommentController.java#L15-L151)中的[addComment](file:///E:/demo/src/main/java/com/example/demo/server/CommentService.java#L24-L34)方法处理：

```java
@PostMapping("/user/addComment")
public ResponseEntity<Map<String, Object>> addComment(@RequestBody Comment comment) {
    Map<String, Object> result = new HashMap<>();
    try {
        Comment savedComment = commentService.addComment(comment);
        articleResourcePathMapper.commentArticle(comment.getArticleId());
        result.put("code", 200);
        result.put("message", "评论添加成功");
        result.put("data", savedComment);
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "评论添加失败: " + e.getMessage());
        return ResponseEntity.status(500).body(result);
    }
}
```

对应的Service实现：

```java
public Comment addComment(Comment comment) {
    if (comment.getTimestamp() == null) {
        comment.setTimestamp(System.currentTimeMillis());
    }
    commentMapper.insertComment(comment);
    return comment;
}
```

### 2. 添加回复

回复功能允许用户对特定评论进行回复，形成评论树状结构：

```java
@PostMapping("/user/addReply")
public ResponseEntity<Map<String, Object>> addReply(@RequestBody Comment comment) {
    Map<String, Object> result = new HashMap<>();
    try {
        Comment savedComment = commentService.addReply(comment);
        articleResourcePathMapper.commentArticle(comment.getArticleId());
        commentService.updateReplyCount(comment.getParentId(),1);
        result.put("code", 200);
        result.put("message", "回复添加成功");
        result.put("data", savedComment);
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "回复添加失败: " + e.getMessage());
        return ResponseEntity.status(500).body(result);
    }
}
```

### 3. 获取文章评论

获取指定文章下的所有评论（不包括回复）：

```java
@GetMapping("/article")
public ResponseEntity<Map<String, Object>> getCommentsByArticleId(@RequestParam Long articleId) {
    Map<String, Object> result = new HashMap<>();
    try {
        List<Comment> comments = commentService.getCommentsByArticleId(articleId);
        result.put("code", 200);
        result.put("message", "获取评论成功");
        result.put("data", comments);
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "获取评论失败: " + e.getMessage());
        return ResponseEntity.status(500).body(result);
    }
}
```

### 4. 获取回复评论

获取某个评论下的所有回复：

```java
@GetMapping("/articleReply")
public ResponseEntity<Map<String, Object>> getReplyComments(@RequestParam Long parentId) {
    Map<String, Object> result = new HashMap<>();
    try {
        List<Comment> comments = commentService.getReplyComments(parentId);
        result.put("code", 200);
        result.put("message", "获取回复评论成功");
        result.put("data", comments);
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        result.put("code", 500);
    }
    return ResponseEntity.status(500).body(result);
}
```

### 5. 删除评论

删除评论功能包含权限验证和关联数据处理：

```java
@GetMapping("/user/deleteComment")
public ResponseEntity<Map<String, Object>> deleteComment(@RequestParam Long timestamp, @RequestHeader("Authorization") String token) {
    Map<String, Object> result = new HashMap<>();
    try {
        token = token.replace("Bearer ", "");
        String email = userInfoMapper.getEmailByToken(token);
        Comment comment = commentService.getCommentById(timestamp);
        if (!email.equals(comment.getEmail())) {
            result.put("code", 403);
            result.put("message", "没有权限");
            return ResponseEntity.status(403).body(result);
        }

        int count = commentService.deleteComment(timestamp);
        articleResourcePathMapper.deleteCommentArticle(comment.getArticleId(), count);
        result.put("code", 200);
        result.put("message", "评论删除成功");
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "评论删除失败: " + e.getMessage());
        return ResponseEntity.status(500).body(result);
    }
}
```

删除评论的Service实现考虑了复杂的关联关系：

```java
public int deleteComment(Long timestamp) {
    List<Long> parentIds = commentMapper.findParentId(timestamp);
    Comment comment = commentMapper.findCommentById(timestamp);
    Long parentId = comment.getParentId();
    if (parentId != null) commentMapper.updateReplyCount(parentId, -parentIds.size()-1);
    if (!parentIds.isEmpty()) commentMapper.deleteComments(parentIds);
    commentMapper.deleteComment(timestamp);
    return parentIds.size()+1;
}
```

## Mapper层实现

使用MyBatis注解和XML配置相结合的方式实现数据库操作：

```java
@Mapper
public interface CommentMapper {
    @Insert("INSERT INTO comments(timestamp, article_id, email, content)VALUES(#{timestamp}, #{articleId}, #{email}, #{content})")
    void insertComment(Comment comment);

    @Select("SELECT * FROM comments WHERE article_id = #{articleId} and parent_id IS NULL")
    List<Comment> findCommentsByArticleId(Long articleId);

    @Select("SELECT * FROM comments WHERE timestamp = #{timestamp}")
    @Result(property = "articleId", column = "article_id")
    @Result(property = "parentId", column = "parent_id")
    Comment findCommentById(Long timestamp);

    @Delete("DELETE FROM comments WHERE timestamp = #{timestamp}")
    void deleteComment(Long timestamp);
    
    // 其他方法...
}
```

对于复杂操作，使用XML配置：

```xml
<delete id="deleteComments" parameterType="list">
    DELETE FROM comments WHERE timestamp IN
    <foreach item="item" collection="list" separator="," open="(" close=")">
        #{item}
    </foreach>
</delete>
```

## 系统特点

### 1. 层次化设计
采用标准的分层架构，各层职责明确，便于维护和扩展。

### 2. 权限控制
删除评论需要验证用户身份，防止恶意删除他人评论。

### 3. 数据一致性
通过数据库外键约束和级联删除机制，确保数据的一致性和完整性。

### 4. 回复功能
支持无限层级回复，构建丰富的评论交互体验。

### 5. 统计功能
自动更新文章评论数等统计数据。

## 总结

我们的博客评论系统通过合理的架构设计和细致的实现，提供了完整的评论功能。系统具备良好的扩展性和维护性，能够满足博客平台的基本需求，并为进一步的功能扩展打下了坚实的基础。

未来可以考虑增加以下功能：
- 评论审核机制
- 评论点赞功能
- 评论通知系统
- 富文本评论支持
- 评论举报功能

这套评论系统已经在生产环境中稳定运行，为用户提供流畅的评论体验。